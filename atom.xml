<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Ricardo Borelli]]></title>
  <link href="http://rabc.github.com/atom.xml" rel="self"/>
  <link href="http://rabc.github.com/"/>
  <updated>2011-12-29T20:22:07-02:00</updated>
  <id>http://rabc.github.com/</id>
  <author>
    <name><![CDATA[Ricardo Borelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sobre o SOPA (ou por que esse tipo de lei deveria causar mais medo em você)]]></title>
    <link href="http://rabc.github.com/2011/12/29/sobre-o-sopa-ou-por-que-esse-tipo-de-lei-deveria-causar-mais-medo-em-voce/"/>
    <updated>2011-12-29T19:18:00-02:00</updated>
    <id>http://rabc.github.com/2011/12/29/sobre-o-sopa-ou-por-que-esse-tipo-de-lei-deveria-causar-mais-medo-em-voce</id>
    <content type="html"><![CDATA[<p>Americanos adoram criar siglas para suas leis: DMCA, ACTA, COICA. E a lei do momento atende pelo nome de SOPA.</p>

<p><strong>tl;dr</strong> SOPA é uma lei em que uma mera <em>acusação</em> já pode fazer com que o seu conteúdo online seja abatido, destruído e esquartejado. Ah, não
somente o seu conteúdo, mas <strong>você</strong> também. O <a href="http://www.gemind.com.br/5746/empresa-tecnologia-contra-sopa-eua/">Gemind</a> e o
<a href="http://www.reddit.com/r/explainlikeimfive/comments/meh0k/eli5_sopa/c30cyoy">Reddit</a> explicam em detalhes.</p>

<h2>Tá, mas o que isso tem a ver comigo que moro em outro hemisfério?</h2>

<p><strong>Tudo.</strong></p>

<p>Praticamente tudo o que você faz na internet está, de uma maneira ou outra, hospedada nos EUA. Se você tem um site com domínio internacional,
provavelmente registrou utilizando o GoDaddy (guarde esse nome).</p>

<p>Colocou no YouTube aquele vídeo do seu sobrinho dançando Lady Gaga? SOPA vai fazer com que o vídeo seja removido.</p>

<p>Hospedou seu blog no Github e escreveu contra alguma empresa americana? SOPA vai abater a bala o seu blog.</p>

<h2>O fiasco do GoDaddy</h2>

<p>Um dos principais pontos do SOPA é que poderá ser requisitado que os provedores de DNS <em>tirem</em> o site do ar. É como se a empresa que vende
água engarrafada fechasse o registro geral de água da sua casa.</p>

<p>Aí um certo dia descobriu-se que o GoDaddy apoia/apoiava o SOPA. O maior provedor de domínios sendo a favor do SOPA significa que esse processo
de tirar arbitrariamente um site do ar ficará mais fácil (e que eles concordam em tirar do ar seus próprios clientes!).</p>

<p>Resultado: <a href="http://www.reddit.com/r/politics/comments/nmnie/godaddy_supports_sopa_im_transferring_51_domains/">milhares</a> de pessoas e
<a href="https://twitter.com/#!/jimmy_wales/status/150287579642740736">sites importantes</a> resolveram tirar seus domínios do GoDaddy e ir para
outros provedores. Alguns desses provedores, como o <a href="http://www.namecheap.com/">NameCheap</a>, souberam aproveitar essa raiva contra o GoDaddy
e se posicionaram <strong>contra</strong> o SOPA.</p>

<p>Primeiro, o GoDaddy <a href="http://www.gemind.com.br/8333/go-daddy-sopa/">falou que isso não teve impacto</a> nos negócios deles. Depois, entrou em modo
<a href="https://plus.google.com/111996409013825587891/posts/7AMw7gDQ7Bi">&#8220;Nós gostamos dos nossos clientes!&#8221;</a> (a.k.a. desespero).</p>

<p>Até que resolveram <a href="http://www.gemind.com.br/8368/go-daddy-volta-atras-apoio-sopa/">tirar o apoio</a> a lei. Você acreditou nessa história?
<a href="http://www.reddit.com/r/technology/comments/npair/godaddy_has_not_withdrawn_its_official/">Pois é&#8230;</a></p>

<h2>Moral da história: o mundo não é mais pequeno</h2>

<p>As principais vozes contra o SOPA são empreendedores americanos (gente grande como Paul Graham e Alexis Ohanian), pois eles sabem como isso
vai afetar o negócio deles. E o negócio deles somos todos nós que acessamos a internet todos os dias.</p>

<p>Por isso, chamo a todos que estão lendo isso e que possuem domínios registrados pelo GoDaddy (startups brasileiras ou simples individuais)
a pesquisarem mais sobre o assunto e se posicionarem.</p>

<p>O planeta pode até ser grande, mas a internet fez o mundo ficar pequeno. Para melhor.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lição #1: Esqueça tudo o que você sabe]]></title>
    <link href="http://rabc.github.com/2011/12/04/licao-1-esqueca-tudo-o-que-voce-sabe/"/>
    <updated>2011-12-04T22:50:00-02:00</updated>
    <id>http://rabc.github.com/2011/12/04/licao-1-esqueca-tudo-o-que-voce-sabe</id>
    <content type="html"><![CDATA[<p>Aprender um novo idioma é difícil. Você se sente como uma criança de 5 anos tentando repetir (sem sucesso) o alfabeto, enquanto procura sentido
e algum padrão no que está falando. Até que você percebe que existem palavras e estrutura parecidas, mas completamente diferente, e desiste
de tentar relacionar o novo idioma com o seu idioma nativo.</p>

<p>Concorda? Agora, me explique: por que não fazer o mesmo ao aprender uma nova linguagem de programação?</p>

<h2>Linguagens diferentes exigem padrões diferentes</h2>

<p><a href="http://en.wikipedia.org/wiki/Software_design_pattern">Design Patterns</a> é o que não falta. Cada um foi concebido com alguma linguagem em mente
(exceto quando autores utilizam pseudo-código, mas divago), utilizando seus padrões já pré-estabelecidos.</p>

<p>O que vejo muito é que alguns programadores tentam fazer um <em>port</em> de sua linguagem preferida ao aprender uma nova linguagem. Com isso, tentam
emular o mesmo ambiente que tinham antes e ganhar tempo no aprendizado. <em>Isso está completamente errado.</em></p>

<p>Pode até funcionar no começo, mas se prepare para as consequências futuras quando o seu software começar a dar problema pelo fato de a linguagem
não ter suportado tão bem a estrutura que você criou.</p>

<div style="text-align:center;">
<img src="http://i.imgur.com/QV88c.jpg" width="400" height="317">
<br />
<p style="font-size:14px;">Quem nunca passou por isso?
</div>


<p>Um DTO que funciona muito bem em Java pode (e vai) dar muitos problemas no seu projeto em Objective-C. A validação <em>server-side</em> única e automática
que existe no .NET vai te dar muito trabalho para imitar em PHP.</p>

<h2>Lição #2: não existe lição número 2</h2>

<p>Cada linguagens já tem um <a href="http://mirnazim.org/writings/python-ecosystem-introduction/">ecosistema</a> e estruturas próprias feitas exatamente
para facilitar sua vida, cabe a você ler as enormes documentações e clicar em seus milhares de links e StackOverflows para descobrir
cada uma delas e como elas funcionam.</p>

<p>Aprender uma nova linguagem é difícil e leva tempo. Lide com isso.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Backend X Mobile App: o que fazer o que não fazer e como fazer]]></title>
    <link href="http://rabc.github.com/2011/11/23/backend-x-mobile-app-o-que-fazer-o-que-nao-fazer-e-como-fazer/"/>
    <updated>2011-11-23T21:43:00-02:00</updated>
    <id>http://rabc.github.com/2011/11/23/backend-x-mobile-app-o-que-fazer-o-que-nao-fazer-e-como-fazer</id>
    <content type="html"><![CDATA[<p>Dificilmente um aplicativo mobile (qualquer plataforma, choose one) vive sozinho, 90% das vezes é necessário um back-end para guardar,
transmitir, processar as informações.</p>

<p>A programação nos dois lados não é igual, tanto em arquitetura quanto em padrões. E sofri muito até perceber isso, por isso apresento aqui
os principais problemas, tanto de programação quanto humanos, que os dois lados encontram.</p>

<h2>Nunca confie no dev na outra ponta (a menos que ele sente na mesma mesa que você)</h2>

<p>A interface de um aplicativo mobile é, sim, complicada e cheia de detalhes. Esses detalhes, muitas vezes, só são vistos durante o desenvolvimento.</p>

<p>Enquanto isso, as informações no back-end estão, geralmente, dispersas. A forma como elas devem ser reunidas e transmitidas afeta a
arquitetura do projeto.</p>

<p>Isso significa que alterações na forma que a informação deve ser enviada e recebida são inevitáveis nas duas pontas do projeto. É irreal esperar
que somente um dos lados decida como isso será feito, esse tipo de decisão tem e deve ser tomada em conjunto (princípio
<a href="http://en.wikipedia.org/wiki/ACID">ACID</a> se aplica nesse caso, já que os dois lados tem que garantir o que acontecerá com a informação).</p>

<p>Se os dois desenvolvedores estiverem sentados perto um do outro, essas alterações e definições ficarão muito mais claras e fáceis de serem
explicadas até que chegue a um consenso ou ao um meio-termo que fique bom para ambos.</p>

<p>E o tema seguinte exemplifica por que isso é o ideal.</p>

<h2>Reutilização não funciona aqui</h2>

<p>&#8220;Não reinvente a roda&#8221;, eles dizem. Se já existe uma API pronta para acessar as informações que o aplicativo precisa, o dev do back-end
não vai (com razão) criar outro serviço somente para o aplicativo. Afinal a informação já está lá, não?</p>

<p>Não, não está.</p>

<p>A forma como a informação deve ser apresentada em um aplicativo é bem diferente de qualquer outra plataforma. A informação tem que ser menor,
mais direta, mais informativa e, ao mesmo tempo, mais condensada. O aplicativo não deve possuir todas as regras de negócio de um projeto, portanto
o back-end deve trazer as informações do jeito certo e avisar caso tenha algum erro.</p>

<p>Um número que outras plataformas apresentaram de modo inteiro, pode acontecer de no aplicativo precisar ser em string e já tratada. Se isso acontecer,
como o desenvolvedor do back-end resolve? Cria-se uma nova chave somente para essa informação? (sim, fizeram isso comigo)</p>

<h2>A conexão pode ser pior do que o dispositivo diz que é</h2>

<p>Conexão móvel não é a melhor do mundo, lide com isso.</p>

<p>Qualquer atraso na conexão pode gerar erro no retorno, informações inconsistentes com o que foi pedido e lentidão para o usuário.</p>

<p>Isso também significa que a conexão do usuário está sendo utilizada enquanto esses erros são tratados pela plataforma. Conexão sendo utilizada
leva a consumo do limite da banda do usuário e leva a um uso maior da bateria do dispositivo.</p>

<p>Isso nos leva ao próximo item, que é&#8230;</p>

<h2>Mobile, só você sabe o quanto de informação precisa (e pode) transmitir</h2>

<p>Se der para fazer cache, faça. Se der para <a href="http://en.wikipedia.org/wiki/HTTP_ETag">verificar no servidor</a> se o conteúdo é novo, faça.</p>

<p>Os dados do usuário não são infinitos e o seu aplicativo não tem direito a consumir tudo sozinho. E quanto mais informações, mais lento o
aplicativo ficará.</p>

<p>O back-end deve sempre retornar somente o necessário. O back-end retorna um item que o aplicativo não está utilizando? Remova-o. O aplicativo
está enviando informação inútil para o back-end? Não envie. E é justamente por esses motivos que o JSON foi estabelecido e padronizado.
Simples, direto e fácil.</p>

<p>Já vivi situações em que o back-end retornava o JSON dos dados dentro de um pacote SOAP (sim, em XML). E o aplicativo enviava
em SOAP também. E a conexão sofria com a quantidade de informações inúteis. E o aplicativo gastava processamento capturando o JSON dentro de um XML.</p>

<h2>Se é back-end, programe em mobile. Se é mobile, programe em back-end</h2>

<p>Já vivi os dois lados. Separados e juntos.</p>

<p>No <a href="http://bit.ly/school_rating">School Rating</a>, produzi todo o back-end em Python e o aplicativo em Objective-C.</p>

<p>Primeiro, o programador back-end (eu) estruturou todo o banco de dados, chamadas e retornos da API, conforme o que o programador mobile (eu) passou.
Aí o programador mobile (eu) descobriu que precisava de algumas informações a mais. O programador back-end (eu) não gostou por ter que alterar
a lógica para incluir mais dados. Mas o programador mobile (eu) foi legal e passou as informações do melhor jeito possível.</p>

<p>Tudo isso me ajudou a ter uma visão de como os dois lados devem interagir e por que alterações nesse caso são necessárias (e quando elas devem
ser necessárias).</p>

<h2>Tipagem de dados foi inventada por um motivo</h2>

<p>Um array deve sempre ser um array. Uma string sempre uma string. E um número sempre um número.</p>

<p>Quem requisita os dados deve fazer o menor tratamento possível, principalmente quando estamos falando de um sistema mobile
com memória e processamento limitados. Se uma determinada chave do JSON é uma lista (array), então <strong>sempre</strong> retorne uma lista, mesmo que ela
seja vazia, e nunca um valor nulo ou string vazia.</p>

<h2>Use e abuse dos http headers</h2>

<p>Os cabeçalhos de uma requisição HTTP serão sempre tratados automaticamente, não importa o método de requisição utlizado, portanto é mais simples
ler o response code do que perder tempo e processamento interpretando o corpo da resposta. O Level 2 do
<a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> explica bem sobre isso.</p>

<p>Isso vale para as duas pontas da requisição. Um <strong>User-Agent</strong> pode diferenciar quem estão fazendo a requisição (se é um Android
ou um iPhone, por exemplo). Um <strong>MIME</strong> pode <a href="http://blog.steveklabnik.com/2011/08/07/some-people-understand-rest-and-http.html">especificar</a>
o que está sendo enviado.</p>

<h2>Simplifique. Ou morra afogado no mar de informações.</h2>

<p>Tudo o que disse leva a esse ponto: simplificar. Informações sem tratamento são apenas dados, e isso não interessa a quem quer a informação.</p>

<p>Simplifique e seja feliz. Seu usuário agradece.</p>
]]></content>
  </entry>
  
</feed>
